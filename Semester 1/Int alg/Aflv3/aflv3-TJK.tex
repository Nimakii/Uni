\documentclass{article}
\usepackage[a4paper]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc} 					% 
\usepackage{lmodern} 						% Skrifttype
\usepackage[danish]{babel}
\usepackage{amsmath,amssymb,bm,mathtools,amsthm}	% Matematik pakker
\usepackage{fancyhdr,lastpage}
\usepackage{subfiles}
\usepackage{graphicx,float}
\usepackage{graphicx}
\usepackage{SASnRdisplay}
\usepackage{mathrsfs}
\setcounter{secnumdepth}{2} 				% No numbering
\fancypagestyle{plain}{
	\fancyhf{}								% Clear header/footer
	\renewcommand{\headrulewidth}{0pt}
	\fancyfoot[C]{Side \thepage \hspace{1pt} of \pageref{LastPage}}
}
\pagestyle{plain}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{appendix}
\usepackage{dsfont}
\usepackage{color}
\usepackage{multicol}
\usepackage{enumerate}
\usepackage{setspace}
\newtheorem{theorem}{Sætning}[section]
\newtheorem{corollary}[theorem]{Korollar}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}[theorem]{Definition}
\theoremstyle{remark}
\newtheorem{obs}[theorem]{Observation}
\newtheorem{remark}[theorem]{Bemærkning}
\newcommand*{\LargerCdot}{\raisebox{-0.25ex}{\scalebox{1.4}{$\cdot$}}}

\addto\captionsenglish{\renewcommand{\figurename}{Figur}}
\DeclarePairedDelimiter\abs{\lvert}{\rvert}
\numberwithin{equation}{section}

\begin{document}
	\author{Thomas Vinther \& Jens Kristian Refsgaard Nielsen}
	\title{Handin 3}
	\date{19-09-18}
	\maketitle
\section*{Analysis of d-ary heaps}
A d-ary heap is like a binary heap, but (with one possible exception) non-leaf nodes have d children instead of 2 children.\\\\
\textbf{Subtask a.)} How would you represent a d-ary heap in an array\\
We represent the d-ary heap as an array by maintaining the heap property $A[Parent(i)] \geq A[i]$ but we change the Parent function as follows
\\Parent(i)
\\\begin{tabular}{l | c | l}
	Time & Line nr & Code \\ \hline
	1 & 1 & if i < d+2 \\
	\indent d & 1 & \indent return 1 \\
	1 & 3 & m = 0 \\
	n/d & 4 & while i > md+1\\
	\indent 1 & 5 & \indent m++ \\
	1 & 6 & return m 
\end{tabular}\\\\
This amounts to the function
\begin{equation}
	\text{Parent}(i) = \begin{cases}
	1 & \text{if }i<d+2\\
	m & \text{if }i=(m-1)d+2,\dots,md+1
	\end{cases}
\end{equation}
With runtime $O(n/d)$, we will later see the importance of keeping the $n/d$ notation.
\\\\\textbf{Subtask b.)} What is the height of a d-ary jeap of n elements in terms of n and d
\\The zeroth level of a d-ary tree has 1 element, this element has d children, and each of these in turn have d children, so in total we end up having $k^h$ nodes at the h'th level. Now it is clear that the height of the tree is $O(\log_d(n))$.
\\\\\textbf{Subtask c.)} Give an efficient implementation of EXTRACT-MAX in a d-ary max-heap. Analyse its running time in terms of d and n.
\\As HEAP-EXTRACT-MAX does not in itself have anything to do with the -aryity of the tree no modification is necessary. However HEAP-EXTRACT-MAX calls MAX-HEAPIFY(A,1), which we indeed need to modify to MAX-HEAPIFY'(A,m):
\\\begin{tabular}{l | c | l}
	Time & Line nr & Code \\ \hline
	1 & 1 & largest = m \\
	d & 2 & kids = [(m-1)d+2,(m-1)d+3,\dots,dm+1] \\
	d & 3 & for k in kids \\
	\indent 2 & 4 & \indent if k $\leq $A.heapsize and A[k] > A[largest] \\
	\indent\indent 1 & 5 & \indent\indent largest = k \\
	1 & 6 & if largest $\neq$ m \\
	\indent3 & 7 & \indent exchange A[m] with A[largest] \\
	a & 8 & \indent MAX-HEAPIFY'(A,largest)
\end{tabular}\\\\
Now consider the runtime, line 1 through 7 takes $1+d+d(2(1))+1(3)= O(d)$ so the call in line 8 is also $a = O(d)$. In the worst case we have to MAX-HEAPIFY' once for each layer of the tree, and we've seen that this was $\log_d(n)$ so we get a total runtime of $O(d\log_d(n)) = O(\log_d(n))$.
\\\\\textbf{Subtask d.) \& e.)} We wish to modify MAX-HEAP-INSERT to work on our d-ary trees.
\\The base kit for MAX-HEAP-INSERT(A,key) will work without modification. However the HEAP-INCREASE-KEY(A,i,key) will need modification as follows
\\\begin{tabular}{l | c | l}
	Time & Line nr & Code \\ \hline
	1 & 1 & if key < A[i] \\
	\indent 1 & 2 & \indent error \\
	1 & 3 & A[i] = key \\
	$\log_d(n)$+n/d & 4 & while i > 1 and A[Parent(i)]>A[i] \\
	\indent 3+n/d & 5 & \indent exchange A[i] with A[Parent(i)] \\
	\indent 1+n/d & 6 & \indent i = Parent(i) 
\end{tabular}\\\\
The n/d is from the Parent function. In total we get
\begin{align*}
	\sum_{j = 1}^{\log_d(n)} \frac{n}{d^j} &= n \sum_{j = 1}^{\log_d(n)} \frac{1}{d^j}\\  &= n \bigg(\frac{1}{d-1}-\frac{1}{d^{\log_d(n)}(d-1)}\bigg) \\
	& = \frac{n-1}{d-1}
\end{align*}
Here the $\frac{n}{d^j}$ summands represent the Parent function being called j times on n, because the parent funciton pretty much just represents division by d. And we call it $\log_d(n)$ times. In total the new version runs in linear time.
\end{document}