diff --git a/src/miniscala/AbstractMachine.scala b/src/miniscala/AbstractMachine.scala
new file mode 100644
index 0000000..a97f735
--- /dev/null
+++ b/src/miniscala/AbstractMachine.scala
@@ -0,0 +1,109 @@
+package miniscala
+
+import scala.collection.mutable
+import scala.io.StdIn
+
+object AbstractMachine {
+
+  case class Executable(freevars: List[String], code: List[Instruction])
+
+  sealed abstract class Instruction
+  case class Const(c: Int) extends Instruction
+  case object Add extends Instruction
+  case object Sub extends Instruction
+  case object Mul extends Instruction
+  case object Div extends Instruction
+  case object Eq extends Instruction
+  case object Lt extends Instruction
+  case object Leq extends Instruction
+  case object And extends Instruction
+  case object Or extends Instruction
+  case object Neg extends Instruction
+  case object Not extends Instruction
+  case class Branch(thencode: List[Instruction], elsecode: List[Instruction]) extends Instruction
+  case object Enter extends Instruction
+  case class Exit(num: Int) extends Instruction
+  case class Read(index: IdIndex) extends Instruction
+
+  type IdIndex = Int // index of identifier in envstack
+
+  def execute(program: Executable, initialEnv: List[Int]): Int = {
+
+    var code: List[Instruction] = program.code // the program code to be executed
+    val opstack = new mutable.ArrayStack[Int] // operand stack, contains values of sub-expressions
+    val envstack = new mutable.ArrayStack[Int] // environment stack, contains values of identifiers
+
+    initialEnv.foreach(c => envstack.push(c))
+
+    try {
+      while (code.nonEmpty) {
+        val inst = code.head
+        code = code.tail
+        trace(s"Current operand stack:     ${opstack.mkString("[", ", ", "]")}")
+        trace(s"Current environment stack: ${envstack.mkString("[", ", ", "]")}")
+        trace(s"Next instruction:          $inst")
+        inst match {
+          case Const(c) =>
+            opstack.push(c)
+          case Add =>
+            val c2 = opstack.pop()
+            val c1 = opstack.pop()
+            opstack.push(c1 + c2)
+          case Sub =>
+            val c2 = opstack.pop()
+            val c1 = opstack.pop()
+            opstack.push(c1 - c2)
+          case Mul =>
+            val c2 = opstack.pop()
+            val c1 = opstack.pop()
+            opstack.push(c1 * c2)
+          case Div =>
+            val c2 = opstack.pop()
+            val c1 = opstack.pop()
+            opstack.push(c1 / c2)
+          case Eq =>
+            ???
+          case Lt =>
+            ???
+          case Leq =>
+            ???
+          case And =>
+            ???
+          case Or =>
+            ???
+          case Neg =>
+            val c = opstack.pop()
+            opstack.push(-c)
+          case Not =>
+            ???
+          case Branch(thencode, elsecode) =>
+            if (opstack.pop() == 1)
+              code = thencode ++ code
+            else
+              code = elsecode ++ code
+          case Enter =>
+            ???
+          case Exit(num) =>
+            for (i <- 1 to num)
+              envstack.pop()
+          case Read(index) =>
+            ???
+        }
+      }
+      opstack.pop()
+    } catch {
+      case ex: Exception => throw new AbstractMachineError(ex)
+    }
+  }
+
+  def makeInitialEnv(program: Executable): List[Int] = {
+    program.freevars.foldLeft(List[Int]())((env, x) => {
+      print(s"Please provide an integer value for the variable $x: ")
+      StdIn.readInt() :: env
+    })
+  }
+
+  def trace(msg: => String): Unit = if (Options.trace) println(msg)
+
+  class AbstractMachineError(ex: Exception) extends Exception(ex)
+}
diff --git a/src/miniscala/Compiler.scala b/src/miniscala/Compiler.scala
new file mode 100644
index 0000000..21c96dd
--- /dev/null
+++ b/src/miniscala/Compiler.scala
@@ -0,0 +1,55 @@
+package miniscala
+
+import miniscala.AbstractMachine._
+import miniscala.Ast._
+
+object Compiler {
+
+  def compile(e: Exp): Executable = {
+
+    def lookup(x: Id, idstack: List[Id]): IdIndex = {
+      // find the position of identifier x in idstack
+      val index = idstack.indexOf(x)
+      if (index == -1) throw new Exception(s"$x not found")
+      index
+    }
+
+    def compile(e: Exp, idstack: List[Id]): List[Instruction] =
+      e match {
+        case IntLit(c) =>
+          List(Const(c))
+        case BoolLit(c) =>
+          ???
+        case BinOpExp(leftexp, op, rightexp) =>
+          compile(leftexp, idstack) ++ compile(rightexp, idstack) ++ List(op match {
+            case PlusBinOp() => Add
+            case MinusBinOp() => Sub
+            case MultBinOp() => Mul
+            case DivBinOp() => Div
+            case EqualBinOp() => ???
+            case LessThanBinOp() => ???
+            case LessThanOrEqualBinOp() => ???
+            case AndBinOp() => ???
+            case OrBinOp() => ???
+            case _ => throw new CompilerError(e)
+          })
+        case UnOpExp(op, exp) =>
+          compile(exp, idstack) ++ List(op match {
+            case NegUnOp() => Neg
+            case NotUnOp() => ???
+          })
+        case IfThenElseExp(condexp, thenexp, elseexp) =>
+          compile(condexp, idstack) ++ List(Branch(compile(thenexp, idstack), compile(elseexp, idstack)))
+        case BlockExp(vals, Nil, Nil, Nil, List(exp)) =>
+          ???
+        case VarExp(x) =>
+          ???
+        case _ => throw new CompilerError(e)
+      }
+
+    val freeids = Vars.freeVars(e).toList.sorted
+    Executable(freeids, compile(e, freeids))
+  }
+
+  class CompilerError(node: AstNode) extends MiniScalaError(s"Sorry, I don't know how to compile $node", node.pos)
+}
diff --git a/src/miniscala/Main.scala b/src/miniscala/Main.scala
index fb123ae..576e325 100644
--- a/src/miniscala/Main.scala
+++ b/src/miniscala/Main.scala
@@ -1,7 +1,7 @@
 package miniscala
 
 import miniscala.Ast.MiniScalaError
-import miniscala.parser.Parser
+import miniscala.parser.{Files, Parser}
 
 object Main {
 
@@ -13,24 +13,45 @@ object Main {
       // read the command-line arguments
       Options.read(args)
 
-      // parse the program
-      val program = Parser.parse(Parser.readFile(Options.file))
+      // load and execute abstract machine code, if enabled
+      if (Options.machine) {
+        val bin = Files.load(Options.file)
+        println(s"Executable (symbolic form): $bin")
+        val initialEnv = AbstractMachine.makeInitialEnv(bin)
+        val result = AbstractMachine.execute(bin, initialEnv)
+        println(s"Output: $result")
 
-      // unparse the program, if enabled
-      if (Options.unparse)
-        println(Unparser.unparse(program))
+      } else {
 
-      // type check the program, if enabled
-      if (Options.types) {
-        val initialTypeEnv = TypeChecker.makeInitialTypeEnv(program)
-        TypeChecker.typeCheck(program, initialTypeEnv, Map())
-      }
+        // parse the program
+        val program = Parser.parse(Parser.readFile(Options.file))
+
+        // unparse the program, if enabled
+        if (Options.unparse)
+          println(Unparser.unparse(program))
+
+        // type check the program, if enabled
+        if (Options.types) {
+          val initialTypeEnv = TypeChecker.makeInitialTypeEnv(program)
+          TypeChecker.typeCheck(program, initialTypeEnv, Map())
+        }
+
+        // execute the program, if enabled
+        if (Options.run) {
+          val initialEnv = Interpreter.makeInitialEnv(program)
+          val (result, _) = Interpreter.eval(program, initialEnv, Map(), Map())
+          println(s"Output: ${Interpreter.valueToString(result)}")
+        }
+
+        // compile to abstract machine code, if enabled
+        if (Options.compile) {
+          val outfile = (if (Options.file.endsWith(".s")) Options.file.substring(0, Options.file.length - 2) else Options.file) + ".sam"
+          val bin = Compiler.compile(program)
+          println(s"Executable (symbolic form): $bin")
+          println(s"Writing executable to $outfile")
+          Files.save(bin, outfile)
+        }
 
-      // execute the program, if enabled
-      if (Options.run) {
-        val initialEnv = Interpreter.makeInitialEnv(program)
-        val (result, _) = Interpreter.eval(program, initialEnv, Map(), Map())
-        println(s"Output: ${Interpreter.valueToString(result)}")
       }
 
     } catch { // report all errors to the console
diff --git a/src/miniscala/Options.scala b/src/miniscala/Options.scala
index 9343ab6..7fc91c8 100644
--- a/src/miniscala/Options.scala
+++ b/src/miniscala/Options.scala
@@ -16,6 +16,8 @@ object Options {
       |  -run      parse and run the program
       |  -types    parse and type-check the program
       |  -trace    trace when running
+      |  -compile  parse and compile to abstract machine code
+      |  -machine  load and run abstract machine code
     """.stripMargin
 
   var unparse = false
@@ -26,6 +28,10 @@ object Options {
 
   var trace = false
 
+  var compile = false
+
+  var machine = false
+
   var file: String = _
 
   /**
@@ -39,6 +45,8 @@ object Options {
           case "-run" => run = true
           case "-types" => types = true
           case "-trace" => trace = true
+          case "-compile" => compile = true
+          case "-machine" => machine = true
           case _ =>
             throw new OptionsError(s"Error: option not recognized: $arg")
         }
diff --git a/src/miniscala/parser/Files.scala b/src/miniscala/parser/Files.scala
new file mode 100644
index 0000000..bffecb3
--- /dev/null
+++ b/src/miniscala/parser/Files.scala
@@ -0,0 +1,34 @@
+package miniscala.parser
+
+import java.io._
+
+import miniscala.AbstractMachine.Executable
+import miniscala.Ast.MiniScalaError
+
+import scala.util.parsing.input.NoPosition
+
+object Files {
+
+  def save(code: Executable, filename: String): Unit = {
+    try {
+      val oos = new ObjectOutputStream(new FileOutputStream(filename))
+      oos.writeObject(code)
+      oos.close()
+    } catch {
+      case e: IOException =>
+        throw new MiniScalaError(s"Unable to write file ${e.getMessage}", NoPosition)
+    }
+  }
+
+  def load(filename: String): Executable = {
+    try {
+      val ois = new ObjectInputStream(new FileInputStream(filename))
+      val code = ois.readObject.asInstanceOf[Executable]
+      ois.close()
+      code
+    } catch {
+      case e: IOException =>
+        throw new MiniScalaError(s"Unable to read file ${e.getMessage}", NoPosition)
+    }
+  }
+}
