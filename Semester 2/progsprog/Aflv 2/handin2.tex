\documentclass[a4paper, 10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc} 					% 
\usepackage{lmodern} 						% Skrifttype
\usepackage[danish]{babel}
\usepackage{amsmath,amssymb,bm,mathtools,amsthm}	% Matematik pakker
\usepackage{fancyhdr,lastpage}
\usepackage{subfiles}
\usepackage{graphicx,float}
\usepackage{graphicx}
\usepackage{SASnRdisplay}
\usepackage{mathrsfs}
\setcounter{secnumdepth}{2} 				% No numbering
\fancypagestyle{plain}{
	\fancyhf{}								% Clear header/footer
	\renewcommand{\headrulewidth}{0pt}
	\fancyfoot[C]{Side \thepage \hspace{1pt} af \pageref{LastPage}}
}
\pagestyle{plain}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{appendix}
\usepackage{dsfont}
\usepackage{color}
\usepackage{multicol}
\usepackage{enumerate}
\usepackage{setspace}
\newtheorem{theorem}{Sætning}[section]
\newtheorem{corollary}[theorem]{Korollar}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}[theorem]{Definition}
\theoremstyle{remark}
\newtheorem{obs}[theorem]{Observation}
\newtheorem{remark}[theorem]{Bemærkning}
\newcommand*{\LargerCdot}{\raisebox{-0.25ex}{\scalebox{1.4}{$\cdot$}}}
\usepackage[utf8]{inputenc}
\usepackage[danish]{babel}

%%% Margins
\usepackage[a4paper,left=1in,right=1in,top=1in,bottom=1in]{geometry}

%%% Title
\title{Aflevering 2}
\author{Studerende 1, 2017xxxxx \and Studerende 2, 2017xxxxx}
\date{X. YYYY 20ZZ}

%%% Code environment
\usepackage{listings}
\usepackage{xcolor}
\definecolor{commentsColor}{rgb}{0.497495, 0.497587, 0.497464}
\definecolor{keywordsColor}{rgb}{0.000000, 0.000000, 0.635294}
\definecolor{stringColor}{rgb}{0.558215, 0.000000, 0.135316}
\lstset{
  basicstyle=\ttfamily\small,                   % the size of the fonts that are used for the code
  breakatwhitespace=false,                      % sets if automatic breaks should only happen at whitespace
  breaklines=true,                              % sets automatic line breaking
  frame=tb,                                     % adds a frame around the code
  commentstyle=\color{commentsColor}\textit,    % comment style
  keywordstyle=\color{keywordsColor}\bfseries,  % keyword style
  stringstyle=\color{stringColor},              % string literal style
  numbers=left,                                 % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                                % how far the line-numbers are from the code
  numberstyle=\tiny\color{commentsColor},       % the style that is used for the line-numbers
  showstringspaces=false,                       % underline spaces within strings only
  tabsize=2,                                    % sets default tabsize to 2 spaces
  language=Scala
}

%% Document
\begin{document}
\maketitle
\section*{Opgave 27}
\subsection*{Kode}
\begin{lstlisting}
  def unparse(e: AstNode): String = e match{
  	// ...
  	case VarExp(x) => s"$x"
  	case BlockExp(vals,exp) =>
  		var valString = ""
	  	var endTuborg = ""
  		for(d <- vals){
	  	valString = valString + "{ val "+d.x+" = "+unparse(d.exp)+" ; "
	  	endTuborg = endTuborg+" }"
	  	}
  		valString+unparse(exp)+endTuborg
    }
\end{lstlisting}
\begin{lstlisting}
  def eval(e: Exp, venv: VarEnv): Int = e match {
    // ...
    case VarExp(x) => 
    	trace("Variable found, lookup of variable value in environment")
    	venv(x)
    case BlockExp(vals, exp) =>
      var venv1 = venv
      for (d <- vals)
        venv1 = venv1 + (d.x -> eval(d.exp, venv1))
        trace("Calculating variable values and adding to variable environment")
      eval(exp, venv1)
  }
\end{lstlisting}
\subsection*{Beskrivelse}
Implementationen af \texttt{BlockExp} og \texttt{ValDecl} i fortolkeren relaterer til den operationelle semantik ved: \\\textbf{VarExp(x):} en ast node af denne type laver et lookup i variable environmentet venv fra eval kaldet for at finde den værdi der er knyttet til x, dette svarer i semantikken til:
\begin{align*}
	\frac{\text{venv}(x)=v}{\text{venv}\vdash x \Rightarrow v}
\end{align*}
\\\textbf{BlockExp(vals,exp):} en ast node af denne type løber listen vals af deklarationer igennem og for hver deklaration d udfører den følgende:
\begin{align*}
	\frac{\text{venv1}\vdash \text{d.exp} \Rightarrow v \text{ }\text{ }\text{ }\text{ }\text{ }\text{ } \text{venv1'}=\text{venv1} [ \text{d.x}\mapsto v ] }{\text{venv1}\vdash \text{val d.x}=\text{d.exp}\Rightarrow\text{venv1'}}
\end{align*}
Hvorefter vi sætter venv1 = venv1', mærket var for sammenlignelighed med slide 40 og 41. Når vi har udført dette for alle ValDecl's d i vals listen har vi kørt venstre side af tælleren i følgende udtryk der repræsenterer hele BlockExp(vals,exp) udtrykket:
\begin{align*}
	\frac{\text{venv}\vdash \text{vals}\Rightarrow\text{venv1}\text{ }\text{ }\text{ }\text{ }\text{ }\text{venv1}\vdash \text{exp} \Rightarrow v}{\text{venv}\vdash\{\text{vals } ; \text{ exp} \}\Rightarrow v}
\end{align*}
Når fortolkeren køres med argumenterne \texttt{-unparse -run -trace examples/ex21.s} fås
\\((x+\{ val z = (y/x) ; (z*2) \})+12)
\\Please provide an integer value for the variable x: 2
\\Please provide an integer value for the variable y: 3
\\BinOpExp found, evaluating left and right expressions
\\BinOpExp found, evaluating left and right expressions
\\Variable found, lookup of variable value in environment
\\BinOpExp found, evaluating left and right expressions
\\Variable found, lookup of variable value in environment
\\Variable found, lookup of variable value in environment
\\Dividing expressions
\\Calculating variable values and adding to variable environment
\\BinOpExp found, evaluating left and right expressions
\\Variable found, lookup of variable value in environment
\\Integer 2 found
\\Multiplying expressions
\\Adding expressions
\\Integer 12 found
\\Adding expressions
\\Output: 16
\section*{Opgave 28}
\section*{Kode}
\begin{lstlisting}
  import scala.collection.mutable.ListBuffer
  
  def simplify(exp: Exp): Exp = {
  	var expNew = exp
	while(expNew != simplify1(expNew)) {
  	expNew = simplify1(expNew)
  	}
  	expNew
  }
  
  def simplifyDecl(vd: ValDecl): ValDecl = vd match{
  	case ValDecl(x,exp) => ValDecl(x,simplify(exp))
  }
  
  def simplify1(exp: Exp): Exp =
  	exp match{
  		case IntLit(c)=> IntLit(c)
  		case VarExp(x)=> VarExp(x)
		case UnOpExp(op,e)=> UnOpExp(op,simplify(e))
		case BlockExp(vals,e)=>
			var vals1 = new ListBuffer[ValDecl]()
  			for (v <- vals){
  				vals1 += simplifyDecl(v)
  			}
  			val vals2 = vals1.toList
  			BlockExp(vals2,simplify(e))
  		case BinOpExp(IntLit(m),ModuloBinOp(),IntLit(n)) =>
  			if((0<=m)&&(m<n)) IntLit(m)
  			else BinOpExp(IntLit(m),ModuloBinOp(),IntLit(n))
  		case BinOpExp(IntLit(m),MaxBinOp(),IntLit(n)) =>
  			if(m == n) IntLit(m)
  			else BinOpExp(IntLit(m),MaxBinOp(),IntLit(n))
  		case BinOpExp(IntLit(m),MultBinOp(),IntLit(n)) =>
  			if ((m < 0) && (n < 0)) BinOpExp(IntLit(-m), MultBinOp(), IntLit(-n))
  			else if (m < 0) UnOpExp(NegUnOp(), BinOpExp(IntLit(-m), MultBinOp(), IntLit(n)))
  			else if (n < 0) UnOpExp(NegUnOp(), BinOpExp(IntLit(m), MultBinOp(), IntLit(-n)))
  			else if (n == 1) IntLit(m)
  			else if (m == 1) IntLit(n)
  			else if ((n == 0) || (m == 0)) IntLit(0)
  			else BinOpExp(IntLit(m), MultBinOp(), IntLit(n))
  		case BinOpExp(le, op, re) => op match {
  			case PlusBinOp() =>
  				if(le == IntLit(0)) simplify(re)
	  			else if(re == IntLit(0)) simplify(le)
  				else BinOpExp(simplify(le),op,simplify(re))
  			case MinusBinOp() =>
  				if(le == re) IntLit(0)
	  			else if (le == IntLit(0)) UnOpExp(NegUnOp(),simplify(re))
  				else re match {
  					case IntLit(m) =>{
  						if (m<0) BinOpExp(simplify(le),PlusBinOp(),IntLit(-m))
  						else BinOpExp(simplify(le),op,simplify(re))
	  				}
  				BinOpExp(simplify(le),op,simplify(re))
  				}
	  		case MultBinOp() =>
  				if(le == IntLit(1)) simplify(re)
  				else if(re == IntLit(1)) simplify(le)
  				else if((le == IntLit(0))||(re == IntLit(0))) IntLit(0)
	  			else BinOpExp(simplify(le),op,simplify(re))
  			case DivBinOp() =>
  				if(le == IntLit(0)) IntLit(0)
  				else if(re == IntLit(0)) throw new IllegalArgumentException("Division by zero")
	  			else if(le == re) IntLit(1)
  				else BinOpExp(simplify(le),op,simplify(re))
  			case ModuloBinOp() =>
  				if(re == IntLit(0)) throw new IllegalArgumentException("Modulation by zero")
  				else BinOpExp(simplify(le),op,simplify(re))
	  		case MaxBinOp() => BinOpExp(simplify(le),op,simplify(re))
  }
\end{lstlisting}
\begin{lstlisting}
  def main(args: Array[String]): Unit = {
    assert((Interpreter.simplify(Parser.parse("3%5")))==(Parser.parse("3")))
    assert(Interpreter.simplify(Parser.parse("3-3"))==Parser.parse("0"))
    assert(Interpreter.simplify(Parser.parse("a/a"))==Parser.parse("1"))
    assert(Interpreter.simplify(Parser.parse("10*0"))==Parser.parse("0"))
    assert(Interpreter.simplify(Parser.parse("0*10"))==Parser.parse("0"))
    assert(Interpreter.simplify(Parser.parse("55+0"))==Parser.parse("55"))
    assert(Interpreter.simplify(Parser.parse("0-12"))==Parser.parse("-12"))
    assert(Interpreter.simplify(Parser.parse("5*1"))==Parser.parse("5"))
    assert(Interpreter.simplify(Parser.parse("0/4"))==Parser.parse("0"))
    assert(Interpreter.simplify(Parser.parse("5max5"))==Parser.parse("5"))
    assert(Interpreter.simplify(Parser.parse("(3*3-9)max(0*9)"))==Parser.parse("(((3*3)-9)max0)"))
    assert(Interpreter.simplify(Parser.parse("(5*(a/(--a)))*(5*(1-1))"))==Parser.parse("0"))
    assert(Interpreter.simplify(Parser.parse("{val x=3*1;x*0}"))==Parser.parse("{ val x = 3 ; 0 }"))
    assert(Interpreter.simplify(Parser.parse("{val x={val z = 7/7 ; z*1};z*x*0}"))==Parser.parse("{ val x = { val z = 1 ; z } ; 0 }"))
  }
\end{lstlisting}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
