\documentclass[a1paper, 10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc} 					% 
\usepackage{lmodern} 						% Skrifttype
\usepackage[danish]{babel}
\usepackage{amsmath,amssymb,bm,mathtools,amsthm}	% Matematik pakker
\usepackage{fancyhdr,lastpage}
\usepackage{subfiles}
\usepackage{graphicx,float}
\usepackage{graphicx}
\usepackage{SASnRdisplay}
\usepackage{mathrsfs}
\setcounter{secnumdepth}{2} 				% No numbering
\fancypagestyle{plain}{
	\fancyhf{}								% Clear header/footer
	\renewcommand{\headrulewidth}{0pt}
	\fancyfoot[C]{Page \thepage \hspace{1pt} af \pageref{LastPage}}
}
\pagestyle{plain}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{appendix}
\usepackage{dsfont}
\usepackage{color}
\usepackage{multicol}
\usepackage{enumerate}
\usepackage{setspace}
\newtheorem{theorem}{Sætning}[section]
\newtheorem{corollary}[theorem]{Korollar}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}[theorem]{Definition}
\theoremstyle{remark}
\newtheorem{obs}[theorem]{Observation}
\newtheorem{remark}[theorem]{Bemærkning}
\newcommand*{\LargerCdot}{\raisebox{-0.25ex}{\scalebox{1.4}{$\cdot$}}}
\usepackage[utf8]{inputenc}
\usepackage[danish]{babel}
\usepackage{qtree}

%%% Margins
\usepackage[a4paper,left=1in,right=1in,top=1in,bottom=1in]{geometry}

%%% Title
\title{Aflevering 2}
\author{Thomas Vinther, 201303874 \and Jens Kristian Nielsen, 201303862}
\date{12. februar 2019}

%%% Code environment
\usepackage{listings}
\usepackage{xcolor}
\definecolor{commentsColor}{rgb}{0.497495, 0.497587, 0.497464}
\definecolor{keywordsColor}{rgb}{0.000000, 0.000000, 0.635294}
\definecolor{stringColor}{rgb}{0.558215, 0.000000, 0.135316}
\lstset{
  basicstyle=\ttfamily\small,                   % the size of the fonts that are used for the code
  breakatwhitespace=false,                      % sets if automatic breaks should only happen at whitespace
  breaklines=true,                              % sets automatic line breaking
  frame=tb,                                     % adds a frame around the code
  commentstyle=\color{commentsColor}\textit,    % comment style
  keywordstyle=\color{keywordsColor}\bfseries,  % keyword style
  stringstyle=\color{stringColor},              % string literal style
  numbers=left,                                 % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                                % how far the line-numbers are from the code
  numberstyle=\tiny\color{commentsColor},       % the style that is used for the line-numbers
  showstringspaces=false,                       % underline spaces within strings only
  tabsize=2,                                    % sets default tabsize to 2 spaces
  language=Scala
}

%% Document
\begin{document}
\maketitle
\section*{Opgave 27}
\subsection*{Kode}
\begin{lstlisting}
  def unparse(e: AstNode): String = e match{
  	// ...
  	case VarExp(x) => s"$x"
  	case BlockExp(vals,exp) =>
  		var valString = ""
	  	var endTuborg = ""
  		for(d <- vals){
	  	valString = valString + "{ val "+d.x+" = "+unparse(d.exp)+" ; "
	  	endTuborg = endTuborg+" }"
	  	}
  		valString+unparse(exp)+endTuborg
    }
\end{lstlisting}
\begin{lstlisting}
  def eval(e: Exp, venv: VarEnv): Int = e match {
    // ...
    case VarExp(x) => 
    	trace(s"Variable $x found, lookup of variable value in environment gave "+venv(x))
    	venv(x)
    case BlockExp(vals, exp) =>
      var venv1 = venv
      for (d <- vals)
        venv1 = venv1 + (d.x -> eval(d.exp, venv1))
        trace("Calculating variable values and adding to variable environment")
      eval(exp, venv1)
  }
\end{lstlisting}
\subsection*{Beskrivelse}
Implementationen af \texttt{BlockExp} og \texttt{ValDecl} i fortolkeren relaterer til den operationelle semantik ved: \\\textbf{VarExp(x):} en ast node af denne type laver et lookup i variable environmentet venv fra eval kaldet for at finde den værdi der er knyttet til x, dette svarer i semantikken til:
\begin{align*}
	\frac{\text{venv}(x)=v}{\text{venv}\vdash x \Rightarrow v}
\end{align*}
\\\textbf{BlockExp(vals,exp):} en ast node af denne type løber listen vals af deklarationer igennem og for hver deklaration d udfører den følgende:
\begin{align*}
	\frac{\text{venv1}\vdash \text{d.exp} \Rightarrow v \text{ }\text{ }\text{ }\text{ }\text{ }\text{ } \text{venv1'}=\text{venv1} [ \text{d.x}\mapsto v ] }{\text{venv1}\vdash \text{val d.x}=\text{d.exp}\Rightarrow\text{venv1'}}
\end{align*}
Hvorefter vi sætter venv1 = venv1', mærket var for sammenlignelighed med slide 40 og 41. Når vi har udført dette for alle ValDecl's d i vals listen har vi kørt venstre side af tælleren i følgende udtryk der repræsenterer hele BlockExp(vals,exp) udtrykket:
\begin{align*}
	\frac{\text{venv}\vdash \text{vals}\Rightarrow\text{venv1}\text{ }\text{ }\text{ }\text{ }\text{ }\text{venv1}\vdash \text{exp} \Rightarrow v}{\text{venv}\vdash\{\text{vals } ; \text{ exp} \}\Rightarrow v}
\end{align*}
Når fortolkeren køres med argumenterne \texttt{-unparse -run -trace examples/ex21.s} fås outputtet: \\
((x+{ val z = (y/x) ; (z*2) })+12)\\
Please provide an integer value for the variable x: 2\\
Please provide an integer value for the variable y: 3\\
BinOpExp found, evaluating left and right expressions\\
BinOpExp found, evaluating left and right expressions\\
Variable x found, lookup of variable value in environment: 2\\
BinOpExp found, evaluating left and right expressions\\
Variable y found, lookup of variable value in environment: 3\\
Variable x found, lookup of variable value in environment: 2\\
Dividing expressions\\
Calculating variable values and adding to variable environment\\
BinOpExp found, evaluating left and right expressions\\
Variable z found, lookup of variable value in environment: 1\\
Integer 2 found\\
Multiplying expressions\\
Adding expressions\\
Integer 12 found\\
Adding expressions\\
Output: 16\\
\\
Fra vores main, parses programmet først, dernæst unparses det og printes i konsollen, øverst i outputtet, da vi har slået unparse til i vores kørsel. Da vi også har slået vores trace funktion til får vi også printet hvilket slags udtryk der evalueres i den givne rækkefølge fra fortolkeren.\\ 
Først skabes det initial variabel enviroment hvor der indtastes værdier til de frie variable, i metoden makeInitialVarEnv fra fortolkeren, der benytter metoden freeVars fra vars, der finder de frie variable.\\
Dernæst evalueres udtrykket. Først findes et BinOpExp, der består af exp:(x+{ val z = (y/x) ; (z*2) }), operatoren + og exp:12. Derefter evalueres det venstre exp, hvor der igen findes et BinOpExp, exp: x, operatoren + og exp: { val z = (y/x) ; (z*2) }. Herefter evalueres venstre siden først, dette var x som er en variabel der bliver slået op i det tilhørende enviroment. \\ 
Det højre udtryk af BinOpExp, mere bestemt: { val z = (y/x) ; (z*2) } bliver dernæst evalueret, her evalueres venstresiden: val z = (y/x), hvor variabel x og y bliver slået op i deres tilhørende enviroment, dernæst udregnes de og værdien af z bliver lagt ind i z's enviroment. Dernæst bliver (z*2) evalueret som et BinOpExp, z bliver slået op i enviroment, og 2 bliver fundet som et heltal. Udregningen udføres "opad" dvs. z*2 som bliver lagt sammen med x, som var blevet slået op til 2. Vi er nu næsten tilbage til det første BinOpExp hvor højresiden evalueres, her finder vi heltallet 12 og operatoren plus og udregningen udføres. Til sidst bliver det samlede resultat printet fra Main.
%%\\Ovenstående beskriver følgende Ast træ\\ 
%%\Tree [.BinOpExp !\qsetw{1cm} [.BinOpExp !\qsetw{0.001cm} Var(x) PlusBinOp [.BlockExp !\qsetw{0.001cm} Var(z) [.BinOpExp !\qsetw{0.001cm} Var(y) PlusBinOp Var(x) ] Var(z) PlusBinOp IntLit(2) ] ] PlusBinOp IntLit(12) ]
%%\qsetw{1cm}
\section*{Opgave 28}
\section*{Kode}
\begin{lstlisting}
  import scala.collection.mutable.ListBuffer
  
  def simplify(exp: Exp): Exp = {
  	var expNew = exp
	while(expNew != simplify1(expNew)) {
  	expNew = simplify1(expNew)
  	}
  	expNew
  }
  
  def simplifyDecl(vd: ValDecl): ValDecl = vd match{
  	case ValDecl(x,exp) => ValDecl(x,simplify(exp))
  }
  
  def simplify1(exp: Exp): Exp =
  	exp match{
  		case IntLit(c)=> IntLit(c)
  		case VarExp(x)=> VarExp(x)
			case UnOpExp(op,e)=> UnOpExp(op,simplify(e))
			case BlockExp(vals,e)=>
				var vals1 = new ListBuffer[ValDecl]()
  				for (v <- vals){
  					vals1 += simplifyDecl(v)
  				}
  				val vals2 = vals1.toList
  				BlockExp(vals2,simplify(e))
	  	case BinOpExp(IntLit(m),ModuloBinOp(),IntLit(n)) =>
	  		if((0<=m)&&(m<n)) IntLit(m)
	  		else BinOpExp(IntLit(m),ModuloBinOp(),IntLit(n))
	  	case BinOpExp(IntLit(m),MaxBinOp(),IntLit(n)) =>
	  		if(m == n) IntLit(m)
	  		else BinOpExp(IntLit(m),MaxBinOp(),IntLit(n))
	  	case BinOpExp(IntLit(m),MultBinOp(),IntLit(n)) =>
	  		if ((m < 0) && (n < 0)) BinOpExp(IntLit(-m), MultBinOp(), IntLit(-n))
	  		else if (m < 0) UnOpExp(NegUnOp(), BinOpExp(IntLit(-m), MultBinOp(), IntLit(n)))
	  		else if (n < 0) UnOpExp(NegUnOp(), BinOpExp(IntLit(m), MultBinOp(), IntLit(-n)))
	  		else if (n == 1) IntLit(m)
	  		else if (m == 1) IntLit(n)
	  		else if ((n == 0) || (m == 0)) IntLit(0)
	  		else BinOpExp(IntLit(m), MultBinOp(), IntLit(n))
	  	case BinOpExp(le, op, re) => op match {
	  		case PlusBinOp() =>
	  			if(le == IntLit(0)) simplify(re)
				else if(re == IntLit(0)) simplify(le)
	  			else BinOpExp(simplify(le),op,simplify(re))
	  		case MinusBinOp() =>
	  			if(le == re) IntLit(0)
				else if (le == IntLit(0)) UnOpExp(NegUnOp(),simplify(re))
  				else re match {
	  				case IntLit(m) =>{
	  					if (m<0) BinOpExp(simplify(le),PlusBinOp(),IntLit(-m))
	  					else BinOpExp(simplify(le),op,simplify(re))
					}
	  			BinOpExp(simplify(le),op,simplify(re))
	  			}
			case MultBinOp() =>
	  			if(le == IntLit(1)) simplify(re)
  				else if(re == IntLit(1)) simplify(le)
  				else if((le == IntLit(0))||(re == IntLit(0))) IntLit(0)
				else BinOpExp(simplify(le),op,simplify(re))
	  		case DivBinOp() =>
  				if(le == IntLit(0)) IntLit(0)
  				else if(re == IntLit(0)) throw new IllegalArgumentException("Division by zero")
				else if(le == re) IntLit(1)
	  			else BinOpExp(simplify(le),op,simplify(re))
  			case ModuloBinOp() =>
  				if(re == IntLit(0)) throw new IllegalArgumentException("Modulation by zero")
  				else BinOpExp(simplify(le),op,simplify(re))
			case MaxBinOp() => BinOpExp(simplify(le),op,simplify(re))
  	}	
\end{lstlisting}
\begin{lstlisting}
  def main(args: Array[String]): Unit = {
    assert((Interpreter.simplify(Parser.parse("3%5")))==(Parser.parse("3")))
    assert(Interpreter.simplify(Parser.parse("3-3"))==Parser.parse("0"))
    assert(Interpreter.simplify(Parser.parse("a/a"))==Parser.parse("1"))
    assert(Interpreter.simplify(Parser.parse("10*0"))==Parser.parse("0"))
    assert(Interpreter.simplify(Parser.parse("0*10"))==Parser.parse("0"))
    assert(Interpreter.simplify(Parser.parse("55+0"))==Parser.parse("55"))
    assert(Interpreter.simplify(Parser.parse("0-12"))==Parser.parse("-12"))
    assert(Interpreter.simplify(Parser.parse("5*1"))==Parser.parse("5"))
    assert(Interpreter.simplify(Parser.parse("0/4"))==Parser.parse("0"))
    assert(Interpreter.simplify(Parser.parse("5max5"))==Parser.parse("5"))
    assert(Interpreter.simplify(Parser.parse("(3*3-9)max(0*9)"))==Parser.parse("(((3*3)-9)max0)"))
    assert(Interpreter.simplify(Parser.parse("(5*(a/(--a)))*(5*(1-1))"))==Parser.parse("0"))
    assert(Interpreter.simplify(Parser.parse("{val x=3*1;x*0}"))==Parser.parse("{ val x = 3 ; 0 }"))
    assert(Interpreter.simplify(Parser.parse("{val x={val z = 7/7 ; z*1};z*x*0}"))==Parser.parse("{ val x = { val z = 1 ; z } ; 0 }"))
    assert(Interpreter.simplify(Parser.parse("55+0"))==Parser.parse("55"))
    assert(Interpreter.simplify(Parser.parse("5*1"))==Parser.parse("5"))
    assert(Interpreter.simplify(Parser.parse("0/4"))==Parser.parse("0"))
    assert(Interpreter.simplify(Parser.parse("5max5"))==Parser.parse("5"))
    assert(Interpreter.simplify(Parser.parse("a/a"))==Parser.parse("1"))
    assert(Interpreter.simplify(Parser.parse("12-12"))==Parser.parse("0"))
    assert(Interpreter.simplify(Parser.parse("(5*1)*(5*(1-1))"))==Parser.parse("0"))
    assert(Interpreter.simplify(Parser.parse("(5*1)*(5*0)"))==Parser.parse("0"))
  }
\end{lstlisting}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
